제 17장 생성자 함수에 의한 객체 생성
===========================================

17.1 Object 생성자 함수
------------------------
* new 연산자와 함께 Object 생성자 함수를 호출하면(new Object()) 빈 객체를 생성하여 반환한다.   
빈 객체를 생성한 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성한다.

* 생성자 함수란 new 연산자와 함께 호출하여 객체를 생성하는 함수를 말함   
생성자 함수에 의해 생성된 객체를 인스턴스라 한다.

17.2 생성자 함수
------------------

### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점
객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하지만, 단 하나의 객체만 생성한다.   
따라서 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야하므로 비효율적.

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점
생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러개를 간편하게 생성할 수 있다.

* 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.   
new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.

### 17.2.3 생성자 함수의 인스턴스 생성 과정
생성자 함수의 역할은 인스턴스를 생성하는 것(필수)과 생성된 인스턴스를 초기화(프로터피 추가 및 초기값 할당)(옵션)이다.   
인스턴스를 생성하고 반환하는 코드는 없지만 js엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다.

__1. 인스턴스 생성과 this__  
암묵적으로 빈 객체가 생성된다. ( -> 인스턴스 )   
인스턴스는 this에 바인딩된다. (그래서 생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리킴)   
바인딩 : 식별자와 값을 연결하는 과정 (이 처리는 함수 몸체의 코드가 한 줄씩 실행되는 런타임 이전에 실행됨)

__2. 인스턴스 초기화__   
생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.   
즉, this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당함.

__3. 인스턴스 반환__   
생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.

### 17.2.4 내부 메서드 [[Call]]과 [[Construct]]   
* 함수는 객체이므로 일반 객체와 동일하게 동작할 수 있다.    
함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가지고 있기 때문이다.   

* 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.   
따라서 함수 객체는 일반 객체가 가지고 있는 내부 슬록과 내부 메서드를 포함하여, 함수로서 동작하기 위해 함수 객체만을 위한 [[Evrionment]], [[FormalParameters]]
등의 내부 슬롯과 [[Call]], [[Construct]] 같은 내부 메서드를 추가로 가지고 있다.   
* 함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고, new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Construct]]가 호출된다.

### 17.2.5 constructor와 non-constructor의 구분
js엔진은 함수 정의를 평가하여 함수 객체를 생성할 때 함수 정의 방식에 따라 함수를 constructor와 non-constructor로 구분한다.   
**constructor** : 생성자 함수로서 호출할 수 있는 함수 (함수 선언문, 함수 표현식, 클래스)   
**non-constructor** : 객체를 생성자 함수로서 호출할 수 없는 함수 (메서드(ES6의 메서드 축약 표현만을 의미), 화살표 함수)

### 17.2.6 new 연산자
일반 함수와 생성자 함수에 특별한 형식적 차이는 없다.   
new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. 다시 말해, 함수 객체의 내부 메서드 [[Call]]이 호출되는 것이 아니라
[[Construct]]가 호출된다.   
new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이어야 한다.   
반대로 new 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출된다. [[Call]]이 호출됨.

### 17.2.7 new.target   
생성자 함수가 new 연산자 없이 호출되는 위험성을 회피하기 위해 ES6에서는 new.tartget을 지원한다.

* new.target은 this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 부른다.   
함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로서 호출되었는지 확인 가능

* new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. new 연산자 없이 일반 함수로서 호출된
함수 내부의 new.target은 undefined이다.


